"""Export mixin for StoryOrchestrator."""

import logging
from io import BytesIO
from pathlib import Path

import src.settings as _settings
from src.services.orchestrator._base import StoryOrchestratorBase
from src.utils.constants import get_language_code

logger = logging.getLogger(__name__)


class ExportMixin(StoryOrchestratorBase):
    """Mixin providing export functionality."""

    def get_full_story(self) -> str:
        """Get the complete story text."""
        if not self.story_state:
            raise ValueError("No story state available.")

        parts = []
        for chapter in self.story_state.chapters:
            if chapter.content:
                parts.append(f"# Chapter {chapter.number}: {chapter.title}\n\n{chapter.content}")
        return "\n\n---\n\n".join(parts)

    def export_to_markdown(self) -> str:
        """Export the story as markdown."""
        if not self.story_state:
            raise ValueError("No story state available.")

        brief = self.story_state.brief
        md_parts = []

        if brief:
            md_parts.extend(
                [
                    f"# {brief.premise[:50]}...\n",
                    f"*Genre: {brief.genre} | Tone: {brief.tone}*\n",
                    f"*Setting: {brief.setting_place}, {brief.setting_time}*\n",
                    "---\n",
                ]
            )
        else:
            md_parts.append("# Untitled Story\n\n---\n")

        for chapter in self.story_state.chapters:
            if chapter.content:
                md_parts.append(f"\n## Chapter {chapter.number}: {chapter.title}\n\n")
                md_parts.append(chapter.content)

        return "\n".join(md_parts)

    def export_to_text(self) -> str:
        """Export the story as plain text."""
        if not self.story_state:
            raise ValueError("No story state available.")

        brief = self.story_state.brief
        text_parts = []

        if brief:
            text_parts.extend(
                [
                    brief.premise[:80],
                    f"Genre: {brief.genre} | Tone: {brief.tone}",
                    f"Setting: {brief.setting_place}, {brief.setting_time}",
                    "=" * 60,
                    "",
                ]
            )
        else:
            text_parts.extend(["Untitled Story", "=" * 60, ""])

        for chapter in self.story_state.chapters:
            if chapter.content:
                text_parts.append(f"CHAPTER {chapter.number}: {chapter.title.upper()}")
                text_parts.append("")
                text_parts.append(chapter.content)
                text_parts.append("")
                text_parts.append("-" * 40)
                text_parts.append("")

        return "\n".join(text_parts)

    def export_to_epub(self) -> bytes:
        """
        Builds an EPUB e-book from the current StoryState and returns the file bytes.

        Uses the story's project name or brief to populate metadata (title, description, genre) and language (from brief.language or "en"), and includes each chapter that has content as an EPUB chapter in order. The generated bytes represent a complete .epub file suitable for saving or streaming.

        Returns:
            bytes: The EPUB file contents.

        Raises:
            ValueError: If there is no story state to export.
        """
        if not self.story_state:
            raise ValueError("No story state available.")

        from ebooklib import epub

        book = epub.EpubBook()

        # Set metadata
        brief = self.story_state.brief
        title = self.story_state.project_name or (brief.premise[:50] if brief else "Untitled Story")
        lang_code = get_language_code(brief.language) if brief else "en"
        book.set_identifier(self.story_state.id)
        book.set_title(title)
        book.set_language(lang_code)

        if brief:
            book.add_metadata("DC", "description", brief.premise)
            book.add_metadata("DC", "subject", brief.genre)

        # Create chapters
        chapters = []
        for ch in self.story_state.chapters:
            if ch.content:
                epub_chapter = epub.EpubHtml(
                    title=f"Chapter {ch.number}: {ch.title}",
                    file_name=f"chapter_{ch.number}.xhtml",
                    lang=lang_code,
                )
                # Convert content to HTML (simple paragraph wrapping)
                html_content = "<br/><br/>".join(
                    f"<p>{para}</p>" for para in ch.content.split("\n\n") if para.strip()
                )
                epub_chapter.content = f"<h1>Chapter {ch.number}: {ch.title}</h1>{html_content}"
                book.add_item(epub_chapter)
                chapters.append(epub_chapter)

        # Add navigation
        book.toc = tuple(chapters)
        book.add_item(epub.EpubNcx())
        book.add_item(epub.EpubNav())

        # Define spine
        book.spine = ["nav", *chapters]

        # Write to bytes
        output = BytesIO()
        epub.write_epub(output, book)
        return output.getvalue()

    def export_to_pdf(self) -> bytes:
        """Export the story as PDF format."""
        if not self.story_state:
            raise ValueError("No story state available.")

        from reportlab.lib.pagesizes import letter
        from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet
        from reportlab.lib.units import inch
        from reportlab.platypus import Flowable, PageBreak, Paragraph, SimpleDocTemplate, Spacer

        buffer = BytesIO()
        doc = SimpleDocTemplate(
            buffer,
            pagesize=letter,
            rightMargin=inch,
            leftMargin=inch,
            topMargin=inch,
            bottomMargin=inch,
        )

        styles = getSampleStyleSheet()
        title_style = ParagraphStyle(
            "CustomTitle",
            parent=styles["Heading1"],
            fontSize=24,
            spaceAfter=30,
        )
        chapter_style = ParagraphStyle(
            "ChapterTitle",
            parent=styles["Heading2"],
            fontSize=18,
            spaceAfter=20,
            spaceBefore=30,
        )
        body_style = ParagraphStyle(
            "Body",
            parent=styles["Normal"],
            fontSize=11,
            leading=16,
            spaceAfter=12,
        )

        story_elements: list[Flowable] = []

        # Title page
        brief = self.story_state.brief
        title = self.story_state.project_name or (brief.premise[:50] if brief else "Untitled Story")
        story_elements.append(Paragraph(title, title_style))

        if brief:
            story_elements.append(
                Paragraph(f"<i>{brief.genre} | {brief.tone}</i>", styles["Normal"])
            )
            story_elements.append(Spacer(1, 0.5 * inch))

        story_elements.append(PageBreak())

        # Chapters
        for ch in self.story_state.chapters:
            if ch.content:
                story_elements.append(Paragraph(f"Chapter {ch.number}: {ch.title}", chapter_style))

                # Split content into paragraphs
                for para in ch.content.split("\n\n"):
                    if para.strip():
                        # Escape special characters for reportlab
                        safe_para = (
                            para.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
                        )
                        story_elements.append(Paragraph(safe_para, body_style))

                story_elements.append(PageBreak())

        doc.build(story_elements)
        return buffer.getvalue()

    def export_to_mobi(self) -> bytes:
        """Export the story as MOBI format (Kindle).

        Note: Amazon discontinued MOBI support in March 2025. EPUB is now the
        recommended format for Kindle devices.
        """
        raise RuntimeError(
            "MOBI format is no longer supported.\n\n"
            "Amazon discontinued MOBI in March 2025. Use EPUB instead:\n"
            "• Send EPUB to your Kindle via 'Send to Kindle' email (yourname@kindle.com)\n"
            "• Use the Kindle app on your phone/tablet - it supports EPUB directly\n"
            "• Use Calibre to convert EPUB to AZW3 if needed"
        )

    def export_story_to_file(self, format: str = "markdown", filepath: str | None = None) -> str:
        """Export the story to a file.

        Args:
            format: Export format ('markdown', 'text', 'json', 'epub', 'pdf')
            filepath: Optional custom path. Defaults to output/stories/<story_id>.<ext>

        Returns:
            The path where the story was exported.
        """
        if not self.story_state:
            raise ValueError("No story to export")

        # Determine file extension and content
        content: str | bytes
        if format == "markdown":
            ext = ".md"
            content = self.export_to_markdown()
        elif format == "text":
            ext = ".txt"
            content = self.export_to_text()
        elif format == "json":
            # JSON export is handled by save_story
            path: str = self.save_story(filepath)
            return path
        elif format == "epub":
            ext = ".epub"
            content = self.export_to_epub()
        elif format == "pdf":
            ext = ".pdf"
            content = self.export_to_pdf()
        else:
            raise ValueError(f"Unsupported export format: {format}")

        # Default export location
        output_path: Path
        if not filepath:
            output_dir = _settings.STORIES_DIR
            output_dir.mkdir(parents=True, exist_ok=True)
            output_path = output_dir / f"{self.story_state.id}{ext}"
        else:
            output_path = Path(filepath)

        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Use isinstance for proper type narrowing that mypy understands
        if isinstance(content, bytes):
            with open(output_path, "wb") as f:
                f.write(content)
        else:
            with open(output_path, "w", encoding="utf-8") as f:
                f.write(content)

        logger.info(f"Story exported to {output_path} ({format} format)")
        return str(output_path)

    def get_statistics(self) -> dict[str, int | float]:
        """Get story statistics including reading time estimate."""
        if not self.story_state:
            raise ValueError("No story state available.")

        total_words = sum(ch.word_count for ch in self.story_state.chapters)
        completed_chapters = sum(1 for ch in self.story_state.chapters if ch.status == "final")
        completed_plot_points = sum(1 for p in self.story_state.plot_points if p.completed)

        # Average reading speed: 200-250 words per minute
        reading_time_min = total_words / 225

        return {
            "total_words": total_words,
            "total_chapters": len(self.story_state.chapters),
            "completed_chapters": completed_chapters,
            "characters": len(self.story_state.characters),
            "established_facts": len(self.story_state.established_facts),
            "plot_points_total": len(self.story_state.plot_points),
            "plot_points_completed": completed_plot_points,
            "reading_time_minutes": round(reading_time_min, 1),
        }
