"""World Health Models - data structures for world validation and health metrics.

Contains Pydantic models for:
- Entity claims and contradictions
- World health metrics and scoring
- Relationship suggestions
"""

import logging

from pydantic import BaseModel, Field

logger = logging.getLogger(__name__)


# =========================================================================
# Contradiction Detection Models
# =========================================================================


class EntityClaim(BaseModel):
    """A claim/fact extracted from an entity's description or attributes.

    Used for contradiction detection to compare facts across entities.
    """

    entity_id: str = Field(description="ID of the entity this claim is about")
    entity_name: str = Field(description="Name of the entity")
    entity_type: str = Field(default="", description="Type of entity (character, location, etc.)")
    claim: str = Field(description="The factual claim being made")
    source_text: str = Field(default="", description="Original text the claim was extracted from")


class Contradiction(BaseModel):
    """A detected contradiction between two claims.

    Represents a logical inconsistency found during world validation.
    """

    claim_a: EntityClaim = Field(description="First claim in the contradiction")
    claim_b: EntityClaim = Field(description="Second claim in the contradiction")
    severity: str = Field(
        default="medium",
        description="Severity level: 'low', 'medium', 'high', or 'critical'",
    )
    explanation: str = Field(description="Explanation of why these claims contradict")
    resolution_suggestion: str = Field(
        default="", description="Suggested way to resolve the contradiction"
    )
    confidence: float = Field(
        default=0.5, ge=0.0, le=1.0, description="Confidence score of the contradiction"
    )


# =========================================================================
# Relationship Suggestion Models
# =========================================================================


class RelationshipSuggestion(BaseModel):
    """A suggested relationship for an entity.

    Generated by the relationship suggestion system based on narrative context.
    """

    source_entity_id: str = Field(description="ID of the source entity")
    source_entity_name: str = Field(description="Name of the source entity")
    target_entity_id: str = Field(description="ID of the target entity")
    target_entity_name: str = Field(description="Name of the target entity")
    relation_type: str = Field(description="Type of relationship (e.g., 'ally_of', 'rival_of')")
    description: str = Field(default="", description="Description of the relationship")
    confidence: float = Field(
        default=0.5, ge=0.0, le=1.0, description="Confidence score for this suggestion"
    )
    bidirectional: bool = Field(
        default=False, description="Whether the relationship goes both ways"
    )


# =========================================================================
# World Health Metrics Models
# =========================================================================


class WorldHealthMetrics(BaseModel):
    """Comprehensive health metrics for a story world.

    Aggregates various quality indicators including entity counts,
    orphan detection, circular relationships, and quality scores.
    """

    # Entity counts
    total_entities: int = Field(default=0, description="Total number of entities")
    entity_counts: dict[str, int] = Field(default_factory=dict, description="Entity counts by type")
    total_relationships: int = Field(default=0, description="Total number of relationships")

    # Orphan detection
    orphan_count: int = Field(default=0, description="Number of orphan entities")
    orphan_entities: list[dict] = Field(
        default_factory=list,
        description="List of orphan entities with id, name, type",
    )

    # Circular relationship detection
    circular_count: int = Field(default=0, description="Number of circular relationship chains")
    circular_relationships: list[dict] = Field(
        default_factory=list, description="Details of circular relationship chains"
    )

    # Quality metrics
    average_quality: float = Field(
        default=0.0, ge=0.0, le=10.0, description="Average quality score across entities"
    )
    quality_distribution: dict[str, int] = Field(
        default_factory=dict,
        description="Distribution of entities by quality bracket (e.g., '0-2': 5)",
    )
    low_quality_entities: list[dict] = Field(
        default_factory=list,
        description="Entities with quality below threshold",
    )

    # Contradiction detection
    contradiction_count: int = Field(default=0, description="Number of detected contradictions")
    contradictions: list[dict] = Field(
        default_factory=list, description="List of detected contradictions"
    )

    # Temporal consistency metrics
    temporal_error_count: int = Field(
        default=0, description="Number of temporal consistency errors"
    )
    temporal_warning_count: int = Field(
        default=0, description="Number of temporal consistency warnings"
    )
    average_temporal_consistency: float = Field(
        default=10.0,
        ge=0.0,
        le=10.0,
        description="Average temporal consistency score across entities",
    )
    temporal_issues: list[dict] = Field(
        default_factory=list,
        description="List of temporal consistency issues with entity_id, message, severity",
    )

    # Computed metrics
    relationship_density: float = Field(
        default=0.0,
        ge=0.0,
        description="Relationships per entity ratio",
    )
    health_score: float = Field(
        default=0.0,
        ge=0.0,
        le=100.0,
        description="Overall world health score (0-100)",
    )

    # Recommendations
    recommendations: list[str] = Field(
        default_factory=list, description="List of recommendations to improve world health"
    )

    def calculate_health_score(self) -> float:
        """Calculate overall health score based on metrics.

        The score is a weighted blend of structural health (60%) and quality (40%).

        Structural scoring (0-100):
        - Base score: 100
        - Orphan penalty: -2 per orphan (max -20)
        - Circular penalty: -5 per circular chain (max -25)
        - Contradiction penalty: -5 per contradiction (max -25)
        - Temporal error penalty: -3 per error (max -15)
        - Temporal warning penalty: -1 per warning (max -5)
        - Density bonus: +10 if density >= 1.5, +5 if >= 1.0

        Quality scoring (0-100):
        - average_quality scaled to 0-100 (quality is 0-10)

        Empty worlds (no entities) always score 0.

        Returns:
            Health score between 0 and 100.
        """
        # Empty worlds score 0 â€” there is nothing healthy about an empty world
        if self.total_entities == 0:
            self.health_score = 0.0
            logger.debug("Calculated health score: 0.0 (empty world)")
            return self.health_score

        structural_score = 100.0

        # Orphan penalty
        orphan_penalty = min(self.orphan_count * 2, 20)
        structural_score -= orphan_penalty

        # Circular relationship penalty
        circular_penalty = min(self.circular_count * 5, 25)
        structural_score -= circular_penalty

        # Contradiction penalty
        contradiction_penalty = min(self.contradiction_count * 5, 25)
        structural_score -= contradiction_penalty

        # Temporal consistency penalty
        temporal_error_penalty = min(self.temporal_error_count * 3, 15)
        temporal_warning_penalty = min(self.temporal_warning_count, 5)
        structural_score -= temporal_error_penalty
        structural_score -= temporal_warning_penalty

        # Density bonus
        if self.relationship_density >= 1.5:
            structural_score += 10
        elif self.relationship_density >= 1.0:
            structural_score += 5

        structural_score = max(0.0, min(100.0, structural_score))

        # Quality score: average_quality is 0-10, scale to 0-100
        quality_score = self.average_quality * 10.0

        # Weighted blend: structural 60%, quality 40%
        score = structural_score * 0.6 + quality_score * 0.4

        # Ensure score is within bounds
        self.health_score = max(0.0, min(100.0, score))
        logger.debug(
            f"Calculated health score: {self.health_score:.1f} "
            f"(structural={structural_score:.1f}, quality={quality_score:.1f}, "
            f"orphan_penalty={orphan_penalty}, circular_penalty={circular_penalty}, "
            f"contradiction_penalty={contradiction_penalty}, "
            f"temporal_penalty={temporal_error_penalty + temporal_warning_penalty})"
        )
        return self.health_score

    def generate_recommendations(self) -> list[str]:
        """Generate recommendations based on health metrics.

        Returns:
            List of actionable recommendations.
        """
        recommendations = []

        # Orphan recommendations
        if self.orphan_count > 0:
            if self.orphan_count == 1 and self.orphan_entities:
                # Guard access to orphan_entities[0] in case list is unexpectedly empty
                orphan_name = self.orphan_entities[0].get("name", "Unknown")
                recommendations.append(
                    f"1 entity has no relationships. Consider adding connections for: {orphan_name}"
                )
            elif self.orphan_count == 1:
                # Fallback if orphan_entities is empty but count says 1
                recommendations.append(
                    "1 entity has no relationships. Consider adding connections."
                )
            else:
                recommendations.append(
                    f"{self.orphan_count} entities have no relationships. "
                    f"Use 'Suggest Relationships' to add meaningful connections."
                )

        # Circular relationship recommendations
        if self.circular_count > 0:
            recommendations.append(
                f"{self.circular_count} circular relationship chain(s) detected. "
                f"Review for unintended loops in hierarchical relationships."
            )

        # Low quality recommendations
        if len(self.low_quality_entities) > 0:
            recommendations.append(
                f"{len(self.low_quality_entities)} entities have low quality scores. "
                f"Consider refining their descriptions using 'Improve Quality'."
            )

        # Contradiction recommendations
        if self.contradiction_count > 0:
            recommendations.append(
                f"{self.contradiction_count} potential contradiction(s) detected. "
                f"Review entity descriptions for consistency."
            )

        # Temporal consistency recommendations
        if self.temporal_error_count > 0:
            recommendations.append(
                f"{self.temporal_error_count} temporal consistency error(s) detected. "
                f"Review entity timelines for conflicts (e.g., characters born before factions founded)."
            )
        elif self.temporal_warning_count > 0:
            recommendations.append(
                f"{self.temporal_warning_count} temporal warning(s) detected. "
                f"Consider reviewing entity dates for accuracy."
            )

        # Density recommendations
        if self.relationship_density < 1.0 and self.total_entities > 5:
            recommendations.append(
                f"Relationship density is low ({self.relationship_density:.2f}). "
                f"Consider adding more relationships to create a richer world."
            )

        # Entity balance recommendations
        if self.entity_counts:
            char_count = self.entity_counts.get("character", 0)
            loc_count = self.entity_counts.get("location", 0)
            if char_count > 0 and loc_count == 0:
                recommendations.append(
                    "No locations defined. Add locations to ground your characters in a world."
                )
            if loc_count > 0 and char_count == 0:
                recommendations.append(
                    "No characters defined. Add characters to populate your locations."
                )

        self.recommendations = recommendations
        logger.debug(
            f"Generated {len(recommendations)} recommendations: "
            f"{recommendations if recommendations else 'none (healthy world)'}"
        )
        return recommendations
